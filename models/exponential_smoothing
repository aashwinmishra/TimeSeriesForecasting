import numpy as np


def single_exponential_smoothing(y: np.array, 
                                 alpha: float=0.3)->np.array:
  """
  Basic, non-optimized Simple Exponential Smoothing (SES) implementation.
  Args:
    y: Time series data.
    alpha: Smoothing factor.
  Returns:
    Smoothed time series.
  """
  y_hat = np.zeros_like(y)
  y_hat[0] = y[0]
  for i in range(1, len(y)):
    y_hat[i] = alpha * y[i-1] + (1-alpha) * y_hat[i-1]
  return y_hat


def double_exponential_smoothing(y: np.array, 
                                 alpha: float=0.5, 
                                 beta: float=0.5,
                                 horizon: int=2)->np.array:
  """
  Basic, non-optimized Double Exponential Smoothing implementation 
  [ie, Holtâ€™s linear trend method].
  Args:
    y: Time series data
    alpha: Smoothing factor
    beta: trend factor
    horizon: horizon to predict beyond the lenght of series
  Returns:
    Doubly smoothed time series.
  """
  n = len(y)
  y_hat = np.zeros(n + horizon)
  y_hat[0] = y[0]
  trend = y[1] - y[0]
  level = y[0]
  for i in range(1, n + 1):
    if i >= n:
      value = y_hat[i-1]
    else:
      value = y[i]
    previous_level = level 
    level = alpha * value + (1 - alpha) * (level + trend)
    trend = beta * (level - previous_level) + (1 - beta) * trend
    y_hat[i] = level + trend 
  if horizon > 1:
    y_hat[n+1:] = level + trend * np.arange(2, horizon + 1)
  return y_hat
